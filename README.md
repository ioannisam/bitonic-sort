# Bitonic Sort using MPI
**Authors:** Ioannis Michalainas, Savvas Tzanetis
**Date:** December 2024

This project implements a distributed sorting algorithm using a **Bitonic Sort** algorithm. The primary objective is to sort a dataset of <strong>N = 2<sup>q+p</sup></strong> processes in ascending order, utilizing the **Message Passing Interface (MPI)** for inter-process communication. The implementation leverages parallel processing to achieve efficient sorting, making it suitable for large-scale data sets. Key components include vector operations, extremum calculations, and min-max comparisons, all orchestrated to perform the bitonic sort in a distributed environment.

## Installation
In order to be able to  compile and run the code, you should first install a **C compiler** as well as a library like **OpenMPI** like so:
```
sudo apt update
sudo apt install openmpi-bin openmpi-common libopenmpi-dev
```
By running `mpirun --version` you can verify the installation. After installing this library you should clone this repository and compile the source code using the included Makefile:
```bash
git clone https://github.com/ioannisam/k-nn.git
cd bitonic-sort
make
```
To run the executable generated by running `make` you can either run the command `make run`, which executes the algorithm with **4** processes and a sequence of **16 random** numbers. In order to use more processes or sort a larger sequence of numbers you should run the following command:
```bash
mpirun -np {np} ./bin/distributed {q} {p}
```
Where **np** is the number of processes, <strong>2<sup>q</sup></strong> is th number of random integers in each process and <strong>2<sup>p</sup></strong> is also the number of processes.
For example, in order to run **4 processes** with **4 integers** per process we need to run:
```bash
mpirun -np 4 ./bin/distributed 2 2
```

## Performance
   This distributed implementation as well as any other algorithm for comparison, where run inside the **Aristotle Cluster** provided by the **Aristotle University of Thessaloniki**, with **4 cores**, splitting the load among **4 processes** or **ranks**.

 As a test, we sorted **33.554.432** ( or 2<sup>25</sup> ) random integers ranging between the numbers **1 - 999**. This is done because the bitonic sorting algorithm can successfully sort only sequences in the **power of 2**.
| **Performance Table** | **Serial**         | **Distributed** | **Quick Sort**     |
|-----------------------|--------------------|-----------------|--------------------|
| **Time Complexity**   | $O(nlog^2(n))$     | $O(log^2(n))$   | $O(nlog(n))$      |
| **Time(Seconds)**     | **1**min **51**sec | **6**sec        | **1**min **24**sec |

## Appendix
For more in-depth information about the project, please refer to the report.pdf document.